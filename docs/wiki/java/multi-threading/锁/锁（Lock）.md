---
sidebar_position: 1
---
>锁的本质是资源的准入控制：通过强制将并发的‘并行’过程‘串行化’，从而保障共享数据的原子性和一致性。

## 锁的本质

**一个标记，占位符**，
- 任何对象都能作为锁
- 锁的信息存在对象头(Object header)的`Mark work`中
  - 锁空闲的时候，标记为`0`
  - 线程抢到锁，通过原子操作（CAS）将标记改为`1`

### 句柄（引导线程）

指引线程去检查对象的状态，是否加锁等。

### 总结

| 层面     | 具体表现                               | 备注 |
|--------|------------------------------------|----|
| Java层面 | 一个普通对象，通过对象头记录锁定信息                 |    |
| Jvm层面  | 一组监视器对象，管理进入、等待、退出                 |    |
| 硬件/内核  | 内存中的一个原子变量（0 或 1）+ 内存屏障指令 + 线程阻塞队列 |



## 锁的概念

限制多个线程同时访问共享数据。

- 锁保护共享数据，是访问许可
- 线程只有持有锁才能访问共享数据
- 锁只能被一个线程持有
- 锁在访问完共享数据之后必须释放

### 术语

**锁的获得（Acquire）**：线程获得锁的动作；

**锁的持有线程**：指持有锁的线程；

**锁的释放（Release）**：释放锁的动作。

**临界区（Critical Section）**：锁的持有进程在获得锁之后和释放锁之间执行的代码。

**排他性（Exclusive）**：一个锁只能由一个线程获得。

## 锁的作用

保护共享数据，实现线程安全。

### 保障原子性

锁的互斥，一次只有一个线程能够获得锁。只有拥有锁的线程才能够访问临界区代码，确保不会有多个线程
同时访问共享数据，使得临界区的代码具有不可分割的特性。

### 保障可见性

>可见性的保障是通过写线程冲刷处理器缓存，读线程刷新处理器缓存实现。

锁的获得隐含刷新处理器缓存的动作；
锁的释放隐含冲刷处理器缓存的动作。

### 保障有序性

在其他线程看来，表现的好像是按顺序执行，实际上还是可能会被重排。


>满足保障原子性、可见性、有序性的要求，需要满足：
> - 线程获取的锁必须是同一个
> - 即使是读取共享数据，也需要获得锁

## 锁的分类

- 内部锁
  
任何一个对象都有关联的锁，这种锁被称为监视器 （Monitor）或者内部锁 （Intrinsic Lock）

**使用synchronized关键字**实现

[内部锁使用demo](https://github.com/mengtaoLu/demo/blob/main/src/com/tml/lock/IntrinsicLockDemo.java)

- 显示锁

`java.util.concurrent.locks.Lock`接口的实例
默认实现是：`ReentrantLock`

最佳实践：

[显式锁demo](https://github.com/mengtaoLu/demo/blob/main/src/com/tml/lock/ExplicitLockDemo.java)

>需要放在`finally`块中释放锁，避免造成泄漏
> 
> 在`try`之前获取锁，否则如果在`try`中获取失败，再到`finally`释放锁或抛出异常。

