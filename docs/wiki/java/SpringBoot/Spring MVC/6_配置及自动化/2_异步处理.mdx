import React, { useState } from 'react';
import { 
  Bolt, 
  ArrowRight, 
  Info, 
  Lightbulb, 
  CheckCircle2, 
  AlertTriangle, 
  ShieldCheck, 
  Rocket,
  Github,
  Coffee,
  Code2
} from 'lucide-react';

export const CodeBlock = ({ code }) => (
  <div className="bg-slate-900 text-slate-200 p-6 rounded-xl font-mono text-sm overflow-x-auto border border-slate-800 shadow-inner">
    <pre><code>{code}</code></pre>
  </div>
);

export const SectionTitle = ({ children, colorClass = "bg-green-500" }) => (
  <h2 className="text-3xl font-bold mb-8 flex items-center text-slate-800">
    <span className={`w-1.5 h-8 ${colorClass} mr-4 rounded-full`}></span>
    {children}
  </h2>
);

export const ImplementationTabs = () => {
  const [activeTab, setActiveTab] = useState('callable');

  const implementationData = {
    callable: {
      title: "使用 Callable<V>",
      description: "这是最基础的异步形式。Spring MVC 会在底层管理的线程池中调用该 Callable。",
      code: `@GetMapping("/async/callable")
public Callable<String> process() {
    log.info("主线程: {}", Thread.currentThread().getName());
    
    return () -> {
        // 模拟 2 秒耗时逻辑
        Thread.sleep(2000); 
        log.info("子线程: {}", Thread.currentThread().getName());
        return "任务完成";
    };
}`,
      footer: "适用于：简单的耗时计算，不需要手动干预异步生命周期的场景。",
      footerType: "info"
    },
    deferred: {
      title: "使用 DeferredResult<V>",
      description: "提供极高的灵活性。业务逻辑可以在任何线程（如消息队列监听器、定时任务）中通过 setResult 触发结果返回。",
      code: `@GetMapping("/async/deferred")
public DeferredResult<String> process() {
    DeferredResult<String> result = new DeferredResult<>(5000L); // 5s超时
    
    // 可以在另一个服务中处理并设置值
    executorService.submit(() -> {
        try {
            String data = heavyService.fetch();
            result.setResult(data);
        } catch (Exception e) {
            result.setErrorResult("失败");
        }
    });
    
    return result;
}`,
      footer: "适用于：长轮询、事件驱动架构、分布式任务同步等场景。",
      footerType: "lightbulb"
    },
    webasync: {
      title: "使用 WebAsyncTask<V>",
      description: "Callable 的增强版，支持为单个请求定义具体的超时时间、指定的线程池以及回调函数。",
      code: `@GetMapping("/async/web-task")
public WebAsyncTask<String> process() {
    Callable<String> callable = () -> {
        Thread.sleep(3000);
        return "Ok";
    };
    
    WebAsyncTask<String> task = new WebAsyncTask<>(
        5000L, 
        "myThreadPool", 
        callable
    );
    
    task.onCompletion(() -> log.info("处理完成"));
    task.onTimeout(() -> "请求超时");
    
    return task;
}`,
      footer: "适用于：需要对单个接口进行精细化超时控制或指定特定线程池的场景。",
      footerType: "check"
    }
  };

  return (
    <div className="bg-white rounded-3xl shadow-sm border border-slate-100 overflow-hidden">
      <div className="flex flex-wrap border-b bg-slate-50/50">
        {Object.keys(implementationData).map((tab) => (
          <button
            key={tab}
            onClick={() => setActiveTab(tab)}
            className={`px-8 py-5 text-sm font-bold transition-all border-b-2 ${
              activeTab === tab 
              ? 'border-green-600 text-green-700 bg-white' 
              : 'border-transparent text-slate-500 hover:bg-slate-100'
            }`}
          >
            {tab.charAt(0).toUpperCase() + tab.slice(1)}
          </button>
        ))}
      </div>
      <div className="p-8 md:p-12">
        <div className="animate-in fade-in slide-in-from-bottom-2 duration-500">
          <h3 className="text-2xl font-bold mb-4 text-slate-800">{implementationData[activeTab].title}</h3>
          <p className="text-slate-600 mb-8 leading-relaxed text-lg">{implementationData[activeTab].description}</p>
          <CodeBlock code={implementationData[activeTab].code} />
          <div className={`mt-8 p-5 rounded-2xl flex items-start ${
            activeTab === 'callable' ? 'bg-blue-50 text-blue-800 border border-blue-100' :
            activeTab === 'deferred' ? 'bg-purple-50 text-purple-800 border border-purple-100' :
            'bg-green-50 text-green-800 border border-green-100'
          }`}>
            <div className="mt-1 mr-4">
              {activeTab === 'callable' && <Info size={20} />}
              {activeTab === 'deferred' && <Lightbulb size={20} />}
              {activeTab === 'webasync' && <CheckCircle2 size={20} />}
            </div>
            <p className="font-medium">{implementationData[activeTab].footer}</p>
          </div>
        </div>
      </div>
    </div>
  );
};

<div className="w-full bg-slate-50 text-slate-900 font-sans selection:bg-green-100 selection:text-green-900 p-4 md:p-8 rounded-xl">
  <div className="w-full">
    
    {/* Hero Section */}
    <section id="overview" className="mb-24 text-center">
      <div className="inline-flex items-center px-4 py-1.5 rounded-full bg-green-50 border border-green-100 text-green-700 text-sm font-medium mb-6">
        <span className="relative flex h-2 w-2 mr-2">
          <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
          <span className="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
        </span>
        Spring Boot 性能优化指南
      </div>
      <h1 className="text-4xl md:text-6xl font-extrabold text-slate-900 mb-8 leading-tight">
        提升系统吞吐量的 <span className="text-transparent bg-clip-text bg-gradient-to-r from-green-600 to-teal-600">异步处理</span>
      </h1>
      <p className="text-xl text-slate-600 max-w-3xl mx-auto leading-relaxed mb-12">
        在高并发场景下，通过释放 Servlet 工作线程来处理更多连接，将耗时业务逻辑交给独立线程池，是优化 Spring Boot 应用的核心策略。
      </p>
      
      {/* Flow Visualizer */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 relative">
        <div className="absolute top-1/2 left-0 right-0 h-0.5 bg-slate-100 -z-10 hidden md:block"></div>
        {[
          { title: "1. 请求进入", desc: "Tomcat 线程接收请求", color: "blue", icon: <Rocket size={20} /> },
          { title: "2. 提交任务", desc: "释放 Servlet 线程，进入 Async 线程", color: "orange", icon: <ArrowRight size={20} /> },
          { title: "3. 结果写回", desc: "任务完成，响应客户端", color: "green", icon: <CheckCircle2 size={20} /> }
        ].map((step, idx) => (
          <div key={idx} className="bg-white p-6 rounded-2xl shadow-sm border border-slate-100 hover:shadow-md transition-shadow">
            <div className={`w-12 h-12 bg-${step.color}-50 text-${step.color}-600 rounded-full flex items-center justify-center mx-auto mb-4`}>
              {step.icon}
            </div>
            <h4 className={`text-${step.color}-700 font-bold mb-2`}>{step.title}</h4>
            <p className="text-sm text-slate-500">{step.desc}</p>
          </div>
        ))}
      </div>
    </section>

    {/* Implementation Tabs */}
    <section id="implementations" className="mb-24">
      <SectionTitle>主流实现方案</SectionTitle>
      <ImplementationTabs />
    </section>

    {/* Configuration */}
    <section id="config" className="mb-24">
      <SectionTitle colorClass="bg-orange-500">配置自定义线程池</SectionTitle>
      <div className="grid grid-cols-1 lg:grid-cols-5 gap-10 items-start">
        <div className="lg:col-span-2 space-y-6">
          <div className="bg-white p-8 rounded-3xl shadow-sm border border-slate-100">
            <h4 className="text-xl font-bold mb-4 text-slate-800">为什么必须配置？</h4>
            <p className="text-slate-600 mb-6 leading-relaxed">
              默认的 <code>SimpleAsyncTaskExecutor</code> 为每个任务创建一个新线程，不复用且不可控。在高并发环境下，这会导致 <b>OOM (内存溢出)</b> 和系统崩溃。
            </p>
            <div className="space-y-4">
              {[
                "核心线程数控制 (Core Pool Size)",
                "最大线程数阈值 (Max Pool Size)",
                "阻塞队列缓冲 (Queue Capacity)",
                "优雅停机支持"
              ].map((item, i) => (
                <div key={i} className="flex items-center text-sm font-semibold text-slate-700">
                  <div className="w-6 h-6 rounded-full bg-green-100 text-green-600 flex items-center justify-center mr-3 flex-shrink-0">
                    <CheckCircle2 size={14} />
                  </div>
                  {item}
                </div>
              ))}
            </div>
          </div>
        </div>
        <div className="lg:col-span-3">
          <CodeBlock code={`@Configuration
public class AsyncWebConfig implements WebMvcConfigurer {

    @Override
    public void configureAsyncSupport(AsyncSupportConfigurer config) {
        config.setTaskExecutor(myExecutor());
        config.setDefaultTimeout(30000); // 设置30秒超时
    }

    @Bean
    public ThreadPoolTaskExecutor myExecutor() {
        ThreadPoolTaskExecutor e = new ThreadPoolTaskExecutor();
        e.setCorePoolSize(10);
        e.setMaxPoolSize(50);
        e.setQueueCapacity(100);
        e.setThreadNamePrefix("WebAsync-");
        e.initialize();
        return e;
    }
}`} />
        </div>
      </div>
    </section>

    {/* Best Practices Grid */}
    <section id="best-practices" className="mb-24">
      <SectionTitle colorClass="bg-red-500">避坑指南 & 最佳实践</SectionTitle>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        <div className="bg-white p-8 rounded-3xl border border-red-100 shadow-sm hover:shadow-md transition-shadow group">
          <div className="w-12 h-12 bg-red-50 text-red-600 rounded-2xl flex items-center justify-center mb-6 group-hover:bg-red-600 group-hover:text-white transition-colors">
            <AlertTriangle size={24} />
          </div>
          <h4 className="text-xl font-bold mb-3 text-slate-800">ThreadLocal 失效</h4>
          <p className="text-slate-600 text-sm leading-relaxed">
            由于业务逻辑在异步线程中执行，原 Servlet 线程的 <code>ThreadLocal</code> 上下文（如 SecurityContext 或用户 Session）不会自动传递。建议使用 <code>DelegatingSecurityContextAsyncTaskExecutor</code> 或显式通过参数传递上下文数据。
          </p>
        </div>
        <div className="bg-white p-8 rounded-3xl border border-blue-100 shadow-sm hover:shadow-md transition-shadow group">
          <div className="w-12 h-12 bg-blue-50 text-blue-600 rounded-2xl flex items-center justify-center mb-6 group-hover:bg-blue-600 group-hover:text-white transition-colors">
            <ShieldCheck size={24} />
          </div>
          <h4 className="text-xl font-bold mb-3 text-slate-800">异常捕获机制</h4>
          <p className="text-slate-600 text-sm leading-relaxed">
            异步线程抛出的异常无法直接被 <code>@ControllerAdvice</code> 捕获。你需要实现 <code>AsyncHandlerInterceptor</code> 或在代码中显式调用 <code>DeferredResult.setErrorResult()</code> 来处理异常流。
          </p>
        </div>
        <div className="bg-white p-8 rounded-3xl border border-green-100 shadow-sm hover:shadow-md transition-shadow group">
          <div className="w-12 h-12 bg-green-50 text-green-600 rounded-2xl flex items-center justify-center mb-6 group-hover:bg-green-600 group-hover:text-white transition-colors">
            <Rocket size={24} />
          </div>
          <h4 className="text-xl font-bold mb-3 text-slate-800">响应式 WebFlux</h4>
          <p className="text-slate-600 text-sm leading-relaxed">
            如果你的应用是 IO 密集型（如大量调用其他微服务或数据库），考虑直接使用 <b>Spring WebFlux</b>。它基于非阻塞 Event Loop 模型，比传统的 Servlet 异步模式能提供更优的性能。
          </p>
        </div>
      </div>
    </section>
  </div>
</div>