---
sidebar_position: 999
---

# Java 多线程基础学习清单

## 一、 线程与进程的基础
> 重点理解：程序是如何在硬件上跑起来的。

* **Q1: 进程 vs 线程**
    * 在操作系统层面，进程和线程的核心区别是什么？
    * 为什么说线程是“轻量级”的？它们共享哪些资源，又独立拥有哪些资源？
* **Q2: 并行 vs 并发**
    * 在单核 CPU 和多核 CPU 环境下，这两个概念的表现有何不同？
* **Q3: Java 线程的状态**
    * Java 线程有哪 6 种状态（参考 `Thread.State` 枚举）？
    * 从 `RUNNABLE` 切换到 `BLOCKED` 或 `WAITING` 分别是由哪些具体操作触发的？

* **Q4: 上下文切换 (Context Switch)**
    * 什么是上下文切换？为什么线程开启的数量超过 CPU 核心数太多，程序性能反而会下降？

---

## 二、 Java 内存模型 (JMM) 与可见性
> 重点理解：为什么多线程程序会产生“诡异”的 Bug。

* **Q5: JMM 的结构**
    * 什么是“主内存”和“工作内存”？
    * 线程读取一个变量时，是如何在两者之间同步数据的？

* **Q6: 三大特性**
    * 并发编程中的 **原子性**、**可见性**、**有序性** 分别指什么？
* **Q7: 指令重排序**
    * 编译器和处理器为什么要对代码进行重排序？这在单线程和多线程下分别有什么影响？
* **Q8: 为什么 `i++` 不是原子操作？**
    * 请从 CPU 执行指令的角度解析 `i++` 包含了哪三个步骤。

---

## 三、 锁的基础概念
> 重点理解：如何控制多个线程对共享资源的访问。

* **Q9: 锁到底锁的是什么？**
    * 当一个线程执行 `synchronized` 方法时，它获取的是代码块的锁，还是对象的锁？
* **Q10: `synchronized` 的用法区别**
    * 修饰 **静态方法** (Static Method) 和 **实例方法** (Instance Method) 时，它们锁住的对象分别是什么？
* **Q11: 可重入锁 (Reentrant Lock)**
    * 什么是锁的“可重入性”？如果 `synchronized` 不支持重入，会出现什么后果？
* **Q12: 死锁 (Deadlock)**
    * 产生死锁的四个必要条件是什么？
    * 在现实代码中，有哪些常见的预防死锁的策略？

* **Q13: 悲观锁 vs 乐观锁**
    * 两者的设计思想有什么区别？
    * 什么是 **CAS (Compare And Swap)** 操作？它属于哪种锁？

---

## 四、 核心关键字预研
> 尝试在学习中寻找这两个关键字的作用。

* **Q14: `volatile` 的作用**
    * 它能保证原子性吗？它主要解决的是什么问题？
* **Q15: `yield()` vs `sleep()` vs `wait()`**
    * 这三个方法都会让出 CPU，但它们对“锁”的持有状态（释放还是不释放）有什么不同？

---

**学习建议：**
1. 建议先看 **《Java并发编程的艺术》** 或 **《深入理解Java虚拟机》** 的并发章节。
2. 动手写个 `Thread` 打印线程状态，直观感受状态切换。